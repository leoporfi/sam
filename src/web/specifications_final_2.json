{
  "meta": {
    "projectName": "SAM - Servicio Web de Gestión RPA",
    "documentVersion": "2.0",
    "createdDate": "2025-01-03",
    "description": "Especificaciones técnicas completas para el desarrollo y mantenimiento del servicio web de interfaz de gestión del proyecto SAM. Incluye arquitectura, endpoints REST, modelo de datos, reglas de negocio, casos de uso y prompts para IA.",
    "promptForAI": "Utiliza este documento como referencia completa para desarrollar, mantener o extender el servicio web de SAM. Sigue estrictamente las reglas de negocio, validaciones y patrones arquitectónicos definidos aquí."
  },
  
  "architecture": {
    "overview": "El servicio web de SAM es una aplicación full-stack que proporciona una interfaz de gestión para administrar robots RPA, programaciones, asignaciones de equipos (VMs) y pools de recursos. Interactúa con la base de datos SAM y el Control Room de Automation Anywhere A360.",
    
    "techStack": {
      "backend": {
        "framework": "FastAPI",
        "language": "Python 3.8+",
        "asyncSupport": true,
        "description": "API REST asíncrona con validación de datos mediante Pydantic"
      },
      "frontend": {
        "framework": "ReactPy",
        "language": "Python 3.8+",
        "uiFramework": "Pico.css v2.1.1",
        "description": "UI reactiva tipo-React escrita en Python con componentes modulares"
      },
      "database": {
        "engine": "Microsoft SQL Server",
        "connectionLayer": "DatabaseConnector (common module)",
        "odbcDriver": "ODBC Driver 17 for SQL Server"
      },
      "externalAPIs": [
        {
          "name": "Automation Anywhere A360 Control Room API",
          "purpose": "Sincronización de robots y equipos",
          "client": "AutomationAnywhereClient"
        }
      ]
    },
    
    "architecturalPatterns": {
      "layeredArchitecture": {
        "presentation": "ReactPy Components (frontend/features/)",
        "api": "FastAPI Routers (backend/api.py)",
        "business": "Service Layer (backend/database.py)",
        "dataAccess": "DatabaseConnector + Stored Procedures"
      },
      "dependencyInjection": {
        "description": "FastAPI Depends para inyectar DatabaseConnector en endpoints",
        "implementation": "DBDependencyProvider pattern"
      },
      "separationOfConcerns": {
        "schemas": "Pydantic models para validación (backend/schemas.py)",
        "apiClient": "Capa de abstracción HTTP (frontend/api_client.py)",
        "hooks": "Lógica de estado reutilizable (frontend/hooks/)"
      }
    },
    
    "directoryStructure": {
      "backend": {
        "api.py": "Definición de endpoints REST (router único)",
        "database.py": "Servicios de acceso a datos (llamadas a SPs)",
        "schemas.py": "Modelos Pydantic para request/response",
        "dependencies.py": "Dependency injection providers"
      },
      "frontend": {
        "app.py": "Componente raíz con routing",
        "api_client.py": "Cliente HTTP asíncrono (httpx)",
        "features/": {
          "dashboard/": "Componentes de gestión de robots",
          "pools/": "Componentes de gestión de pools",
          "modals/": "Modales reutilizables"
        },
        "shared/": {
          "layout.py": "Layout principal y header",
          "common_components.py": "Componentes UI reutilizables",
          "notifications.py": "Sistema de toasts"
        },
        "hooks/": "Custom hooks (use_robots, use_pools, etc.)",
        "utils/": "Utilidades (validaciones, excepciones)"
      }
    }
  },
  
  "dataModel": {
    "tables": {
      "Robots": {
        "description": "Almacena la información de los robots RPA sincronizados desde A360",
        "primaryKey": "RobotId",
        "columns": [
          {
            "name": "RobotId",
            "type": "INT",
            "nullable": false,
            "description": "ID único del robot en A360 (origen externo)"
          },
          {
            "name": "Robot",
            "type": "NVARCHAR(100)",
            "nullable": false,
            "description": "Nombre del robot"
          },
          {
            "name": "Descripcion",
            "type": "NVARCHAR(4000)",
            "nullable": true,
            "description": "Descripción del robot"
          },
          {
            "name": "Parametros",
            "type": "NVARCHAR(MAX)",
            "nullable": true,
            "description": "JSON con parámetros de ejecución por defecto"
          },
          {
            "name": "Activo",
            "type": "BIT",
            "nullable": false,
            "default": 1,
            "description": "Indica si el robot está activo en SAM"
          },
          {
            "name": "EsOnline",
            "type": "BIT",
            "nullable": false,
            "default": 0,
            "description": "Indica si el robot ejecuta a demanda (Online) o por programación"
          },
          {
            "name": "MinEquipos",
            "type": "INT",
            "nullable": false,
            "default": 1,
            "description": "Número mínimo de equipos que el balanceador mantendrá asignados"
          },
          {
            "name": "MaxEquipos",
            "type": "INT",
            "nullable": false,
            "default": -1,
            "description": "Número máximo de equipos (ilimitado si es -1)"
          },
          {
            "name": "PrioridadBalanceo",
            "type": "INT",
            "nullable": false,
            "default": 100,
            "description": "Prioridad para asignación de recursos (mayor número = mayor prioridad)"
          },
          {
            "name": "TicketsPorEquipoAdicional",
            "type": "INT",
            "nullable": true,
            "default": 10,
            "description": "Ratio de tickets necesarios para asignar un equipo adicional"
          },
          {
            "name": "PoolId",
            "type": "INT",
            "nullable": true,
            "foreignKey": "Pools(PoolId)",
            "description": "ID del pool al que pertenece (NULL = Pool General)"
          }
        ],
        "businessRules": [
          "Un robot NO puede tener EsOnline=1 y programaciones activas simultáneamente",
          "MinEquipos debe ser >= 0",
          "MaxEquipos debe ser >= MinEquipos o -1 (ilimitado)",
          "PrioridadBalanceo debe estar entre 0 y 100",
          "TicketsPorEquipoAdicional debe ser > 0"
        ]
      },
      
      "Equipos": {
        "description": "Almacena la información de los equipos (VMs) sincronizados desde A360",
        "primaryKey": "EquipoId",
        "columns": [
          {
            "name": "EquipoId",
            "type": "INT",
            "nullable": false,
            "description": "ID único del equipo en A360"
          },
          {
            "name": "Equipo",
            "type": "NVARCHAR(100)",
            "nullable": false,
            "description": "Nombre del equipo (hostname)"
          },
          {
            "name": "UserId",
            "type": "INT",
            "nullable": false,
            "description": "ID del usuario asignado al equipo en A360"
          },
          {
            "name": "UserName",
            "type": "NVARCHAR(50)",
            "nullable": true,
            "description": "Nombre del usuario asignado"
          },
          {
            "name": "Licencia",
            "type": "NVARCHAR(50)",
            "nullable": true,
            "description": "Tipo de licencia (ATTENDEDRUNTIME, etc.)"
          },
          {
            "name": "Activo_SAM",
            "type": "BIT",
            "nullable": false,
            "default": 1,
            "description": "Indica si el equipo está activo y disponible en SAM"
          },
          {
            "name": "EstadoBalanceador",
            "type": "NVARCHAR(50)",
            "nullable": true,
            "description": "Estado asignado por el balanceador (opcional)"
          },
          {
            "name": "PermiteBalanceoDinamico",
            "type": "BIT",
            "nullable": false,
            "default": 1,
            "description": "Indica si el equipo puede ser asignado dinámicamente por el balanceador"
          },
          {
            "name": "PoolId",
            "type": "INT",
            "nullable": true,
            "foreignKey": "Pools(PoolId)",
            "description": "ID del pool al que pertenece (NULL = Pool General)"
          }
        ],
        "businessRules": [
          "Un equipo con PermiteBalanceoDinamico=0 NO puede ser asignado por el balanceador",
          "Un equipo programado o reservado debe tener PermiteBalanceoDinamico=0",
          "Solo equipos con Licencia='ATTENDEDRUNTIME' pueden ser balanceados dinámicamente por defecto"
        ]
      },
      
      "Asignaciones": {
        "description": "Tabla de relación entre robots y equipos (asignaciones dinámicas, programadas y manuales)",
        "uniqueConstraint": "(RobotId, EquipoId)",
        "columns": [
          {
            "name": "RobotId",
            "type": "INT",
            "nullable": false,
            "foreignKey": "Robots(RobotId)",
            "description": "ID del robot asignado"
          },
          {
            "name": "EquipoId",
            "type": "INT",
            "nullable": false,
            "foreignKey": "Equipos(EquipoId)",
            "description": "ID del equipo asignado"
          },
          {
            "name": "EsProgramado",
            "type": "BIT",
            "nullable": true,
            "default": 0,
            "description": "Indica si es una asignación programada"
          },
          {
            "name": "Reservado",
            "type": "BIT",
            "nullable": true,
            "default": 0,
            "description": "Indica si es una asignación manual (reserva)"
          },
          {
            "name": "FechaAsignacion",
            "type": "DATETIME2(0)",
            "nullable": true,
            "default": "GETDATE()",
            "description": "Fecha y hora de la asignación"
          },
          {
            "name": "AsignadoPor",
            "type": "NVARCHAR(50)",
            "nullable": true,
            "description": "Origen de la asignación (Balanceador, WebApp, SP_Programacion_X)"
          },
          {
            "name": "ProgramacionId",
            "type": "INT",
            "nullable": true,
            "foreignKey": "Programaciones(ProgramacionId)",
            "description": "ID de la programación asociada (si aplica)"
          }
        ],
        "businessRules": [
          "Una asignación NO puede tener EsProgramado=1 y Reservado=1 simultáneamente",
          "Si EsProgramado=1, debe existir un ProgramacionId válido",
          "Si Reservado=1, el equipo debe ser marcado manualmente desde la interfaz web",
          "El balanceador SOLO gestiona asignaciones con EsProgramado=0 y Reservado=0"
        ]
      },
      
      "Programaciones": {
        "description": "Almacena las programaciones de ejecución para robots",
        "primaryKey": "ProgramacionId",
        "columns": [
          {
            "name": "ProgramacionId",
            "type": "INT IDENTITY(1,1)",
            "nullable": false,
            "description": "ID único de la programación"
          },
          {
            "name": "RobotId",
            "type": "INT",
            "nullable": false,
            "foreignKey": "Robots(RobotId)",
            "description": "ID del robot programado"
          },
          {
            "name": "TipoProgramacion",
            "type": "NVARCHAR(20)",
            "nullable": false,
            "checkConstraint": "'Diaria', 'Semanal', 'Mensual', 'Especifica'",
            "description": "Tipo de recurrencia de la programación"
          },
          {
            "name": "HoraInicio",
            "type": "TIME(0)",
            "nullable": false,
            "description": "Hora de inicio de la ejecución"
          },
          {
            "name": "DiasSemana",
            "type": "NVARCHAR(20)",
            "nullable": true,
            "description": "Días de la semana (ej: 'Lu,Ma,Mi') para tipo Semanal"
          },
          {
            "name": "DiaDelMes",
            "type": "INT",
            "nullable": true,
            "description": "Día del mes (1-31) para tipo Mensual"
          },
          {
            "name": "FechaEspecifica",
            "type": "DATE",
            "nullable": true,
            "description": "Fecha exacta para tipo Especifica"
          },
          {
            "name": "Tolerancia",
            "type": "INT",
            "nullable": true,
            "default": 60,
            "description": "Ventana de tiempo en minutos para ejecutar tras HoraInicio"
          },
          {
            "name": "Activo",
            "type": "BIT",
            "nullable": true,
            "default": 1,
            "description": "Indica si la programación está activa"
          },
          {
            "name": "FechaCreacion",
            "type": "DATETIME2(0)",
            "nullable": true,
            "default": "GETDATE()",
            "description": "Fecha de creación"
          },
          {
            "name": "FechaModificacion",
            "type": "DATETIME2(0)",
            "nullable": true,
            "description": "Fecha de última modificación"
          }
        ],
        "businessRules": [
          "Un robot con EsOnline=1 NO puede tener programaciones activas",
          "Si TipoProgramacion='Semanal', DiasSemana es obligatorio",
          "Si TipoProgramacion='Mensual', DiaDelMes es obligatorio",
          "Si TipoProgramacion='Especifica', FechaEspecifica es obligatoria",
          "Tolerancia debe estar entre 0 y 1440 minutos (24 horas)"
        ]
      },
      
      "Pools": {
        "description": "Almacena los pools de recursos para segmentación de robots y equipos",
        "primaryKey": "PoolId",
        "columns": [
          {
            "name": "PoolId",
            "type": "INT IDENTITY(1,1)",
            "nullable": false,
            "description": "ID único del pool"
          },
          {
            "name": "Nombre",
            "type": "NVARCHAR(100)",
            "nullable": false,
            "unique": true,
            "description": "Nombre único del pool"
          },
          {
            "name": "Descripcion",
            "type": "NVARCHAR(500)",
            "nullable": true,
            "description": "Descripción del pool"
          },
          {
            "name": "Activo",
            "type": "BIT",
            "nullable": false,
            "default": 1,
            "description": "Indica si el pool está activo"
          },
          {
            "name": "FechaCreacion",
            "type": "DATETIME2(0)",
            "nullable": false,
            "default": "GETDATE()",
            "description": "Fecha de creación"
          },
          {
            "name": "FechaModificacion",
            "type": "DATETIME2(0)",
            "nullable": true,
            "description": "Fecha de última modificación"
          }
        ],
        "businessRules": [
          "El Pool General se representa con PoolId=NULL en Robots y Equipos",
          "No se puede eliminar un pool si tiene recursos asignados (se deben desasignar primero)",
          "El nombre del pool debe ser único en el sistema"
        ]
      },
      
      "Ejecuciones": {
        "description": "Registra las ejecuciones de robots (iniciadas por el Lanzador)",
        "primaryKey": "EjecucionId",
        "relevantColumns": [
          "EjecucionId",
          "DeploymentId",
          "RobotId",
          "EquipoId",
          "FechaInicio",
          "FechaFin",
          "Estado"
        ],
        "note": "Tabla gestionada principalmente por el servicio Lanzador. La interfaz web la consulta para validaciones."
      },
      
      "HistoricoBalanceo": {
        "description": "Auditoría de decisiones del servicio Balanceador",
        "primaryKey": "HistoricoId",
        "relevantColumns": [
          "FechaBalanceo",
          "RobotId",
          "TicketsPendientes",
          "EquiposAsignadosAntes",
          "EquiposAsignadosDespues",
          "AccionTomada",
          "Justificacion",
          "PoolId"
        ],
        "note": "Tabla de solo lectura desde la interfaz web. Útil para dashboards de rendimiento."
      }
    },
    
    "views": {
      "AsignacionesView": {
        "description": "Vista que une Asignaciones con nombres de Robots y Equipos",
        "columns": ["Robot", "Equipo", "RobotId", "EquipoId", "EsProgramado", "Reservado"],
        "usage": "Consultas rápidas para mostrar asignaciones con nombres legibles"
      },
      "EquiposAsignados": {
        "description": "Cuenta de equipos asignados por robot",
        "columns": ["Robot", "Equipos"],
        "usage": "Dashboard de robots (columna CantidadEquiposAsignados)"
      },
      "EstadoBalanceadorTiempoReal": {
        "description": "Estado en tiempo real del balanceador por robot",
        "usage": "Dashboard de monitoreo del balanceador (futuro)"
      }
    },
    
    "storedProcedures": {
      "MergeRobots": {
        "description": "Sincroniza robots desde A360 usando un TVP",
        "parameters": ["@RobotList RobotListType READONLY"],
        "usage": "Llamado durante la sincronización manual"
      },
      "MergeEquipos": {
        "description": "Sincroniza equipos desde A360 usando un TVP",
        "parameters": ["@EquipoList EquipoListType READONLY"],
        "usage": "Llamado durante la sincronización manual"
      },
      "CrearProgramacion": {
        "description": "Crea una nueva programación para un robot",
        "parameters": [
          "@Robot NVARCHAR(100)",
          "@Equipos NVARCHAR(MAX)",
          "@TipoProgramacion NVARCHAR(20)",
          "@HoraInicio TIME",
          "@Tolerancia INT",
          "@DiasSemana NVARCHAR(20)",
          "@DiaDelMes INT",
          "@FechaEspecifica DATE"
        ],
        "sideEffects": [
          "Marca robot.EsOnline = 0",
          "Crea asignaciones con EsProgramado=1",
          "Establece PermiteBalanceoDinamico=0 en equipos asignados"
        ]
      },
      "ActualizarProgramacionCompleta": {
        "description": "Actualiza una programación existente",
        "parameters": ["@ProgramacionId INT", "@RobotId INT", "..."],
        "sideEffects": [
          "Desprograma equipos que ya no están en la lista",
          "Programa nuevos equipos",
          "Actualiza PermiteBalanceoDinamico según corresponda"
        ]
      },
      "EliminarProgramacionCompleta": {
        "description": "Elimina una programación y limpia asignaciones",
        "parameters": ["@ProgramacionId INT", "@RobotId INT"],
        "sideEffects": [
          "Elimina asignaciones programadas (no reservadas)",
          "Habilita PermiteBalanceoDinamico si el equipo queda libre"
        ]
      },
      "ListarPools": {
        "description": "Obtiene todos los pools con contadores de recursos",
        "returns": ["PoolId", "Nombre", "Descripcion", "Activo", "CantidadRobots", "CantidadEquipos"]
      },
      "CrearPool": {
        "description": "Crea un nuevo pool de recursos",
        "parameters": ["@Nombre NVARCHAR(100)", "@Descripcion NVARCHAR(500)"],
        "returns": "Pool recién creado con OUTPUT INSERTED.*"
      },
      "ActualizarPool": {
        "description": "Actualiza un pool existente",
        "parameters": ["@PoolId INT", "@Nombre NVARCHAR(100)", "@Descripcion NVARCHAR(500)"]
      },
      "EliminarPool": {
        "description": "Elimina un pool (desasigna recursos primero)",
        "parameters": ["@PoolId INT"],
        "sideEffects": ["Establece PoolId=NULL en Robots y Equipos asociados"]
      },
      "AsignarRecursosAPool": {
        "description": "Asigna robots y equipos a un pool",
        "parameters": [
          "@PoolId INT",
          "@RobotIds IdListType READONLY",
          "@EquipoIds IdListType READONLY"
        ]
      },
      "ObtenerRecursosParaPool": {
        "description": "Obtiene recursos asignados y disponibles para un pool",
        "parameters": ["@PoolId INT"],
        "returns": "Dos conjuntos de resultados: asignados y disponibles"
      }
    }
  },
  
  "apiEndpoints": {
    "baseUrl": "http://localhost:8000",
    "prefix": "/api",
    
    "robots": {
      "GET /api/robots": {
        "description": "Obtiene la lista de robots con filtros y paginación",
        "method": "GET",
        "queryParameters": {
          "name": {
            "type": "string",
            "required": false,
            "description": "Filtro parcial por nombre de robot"
          },
          "active": {
            "type": "boolean",
            "required": false,
            "description": "Filtro por estado activo"
          },
          "online": {
            "type": "boolean",
            "required": false,
            "description": "Filtro por modo online"
          },
          "page": {
            "type": "integer",
            "required": false,
            "default": 1,
            "description": "Número de página"
          },
          "size": {
            "type": "integer",
            "required": false,
            "default": 20,
            "min": 1,
            "max": 100,
            "description": "Cantidad de resultados por página"
          },
          "sort_by": {
            "type": "string",
            "required": false,
            "default": "Robot",
            "enum": ["Robot", "CantidadEquiposAsignados", "Activo", "EsOnline", "TieneProgramacion", "PrioridadBalanceo", "TicketsPorEquipoAdicional"],
            "description": "Campo por el cual ordenar"
          },
          "sort_dir": {
            "type": "string",
            "required": false,
            "default": "asc",
            "enum": ["asc", "desc"],
            "description": "Dirección del ordenamiento"
          }
        },
        "responseSchema": {
          "total_count": "integer",
          "page": "integer",
          "size": "integer",
          "robots": [
            {
              "RobotId": "integer",
              "Robot": "string",
              "Descripcion": "string",
              "MinEquipos": "integer",
              "MaxEquipos": "integer",
              "EsOnline": "boolean",
              "Activo": "boolean",
              "PrioridadBalanceo": "integer",
              "TicketsPorEquipoAdicional": "integer",
              "CantidadEquiposAsignados": "integer",
              "TieneProgramacion": "boolean"
            }
          ]
        },
        "statusCodes": {
          "200": "Éxito",
          "500": "Error del servidor"
        }
      },
      
      "PATCH /api/robots/{robot_id}": {
        "description": "Actualiza el estado de un robot (Activo o EsOnline)",
        "method": "PATCH",
        "pathParameters": {
          "robot_id": {
            "type": "integer",
            "required": true,
            "description": "ID del robot a actualizar"
          }
        },
        "requestBody": {
          "Activo": {
            "type": "boolean",
            "required": false,
            "description": "Nuevo estado de Activo"
          },
          "EsOnline": {
            "type": "boolean",
            "required": false,
            "description": "Nuevo estado de EsOnline"
          }
        },
        "businessRules": [
          "Solo se puede enviar UN campo por petición (Activo O EsOnline)",
          "Si se intenta establecer EsOnline=1 y el robot tiene programaciones activas, el backend debe rechazarlo"
        ],
        "statusCodes": {
          "200": "Actualización exitosa",
          "400": "Campo no válido o violación de regla de negocio",
          "404": "Robot no encontrado",
          "500": "Error del servidor"
        }
      },
      
      "PUT /api/robots/{robot_id}": {
        "description": "Actualiza los detalles completos de un robot",
        "method": "PUT",
        "pathParameters": {
          "robot_id": {
            "type": "integer",
            "required": true
          }
        },
        "requestBody": {
          "Robot": "string (requerido)",
          "Descripcion": "string (opcional)",
          "MinEquipos": "integer (requerido, >= 0)",
          "MaxEquipos": "integer (requerido, >= MinEquipos o -1)",
          "PrioridadBalanceo": "integer (requerido, 0-100)",
          "TicketsPorEquipoAdicional": "integer (opcional, > 0)"
        },
        "validations": [
          "MinEquipos >= 0",
          "MaxEquipos >= MinEquipos o MaxEquipos = -1",
          "PrioridadBalanceo entre 0 y 100",
          "TicketsPorEquipoAdicional > 0 si está presente"
        ],
        "statusCodes": {
          "200": "Actualización exitosa",
          "400": "Datos inválidos",
          "404": "Robot no encontrado",
          "500": "Error del servidor"
        }
      },
      
      "POST /api/robots": {
        "description": "Crea un nuevo robot manualmente",
        "method": "POST",
        "requestBody": {
          "RobotId": "integer (requerido, ID de A360)",
          "Robot": "string (requerido)",
          "Descripcion": "string (opcional)",
          "Activo": "boolean (requerido)",
          "EsOnline": "boolean (requerido)",
          "MinEquipos": "integer (default: 1)",
          "MaxEquipos": "integer (default: -1)",
          "PrioridadBalanceo": "integer (default: 100)",
          "TicketsPorEquipoAdicional": "integer (default: 10)"
        },
        "statusCodes": {
          "201": "Robot creado exitosamente",
          "409": "RobotId ya existe",
          "500": "Error del servidor"
        }
      }
    },
    
    "asignaciones": {
      "GET /api/robots/{robot_id}/asignaciones": {
        "description": "Obtiene las asignaciones de un robot",
        "method": "GET",
        "responseSchema": [
          {
            "RobotId": "integer",
            "EquipoId": "integer",
            "Equipo": "string",
            "EsProgramado": "boolean",
            "Reservado": "boolean"
          }
        ],
        "statusCodes": {
          "200": "Éxito",
          "500": "Error del servidor"
        }
      },
      
      "GET /api/equipos/disponibles/{robot_id}": {
        "description": "Obtiene equipos disponibles para asignar a un robot",
        "method": "GET",
        "businessLogic": "Retorna equipos con Activo_SAM=1, PermiteBalanceoDinamico=1 y que NO estén asignados al robot",
        "responseSchema": [
          {
            "EquipoId": "integer",
            "Equipo": "string"
          }
        ],
        "statusCodes": {
          "200": "Éxito",
          "500": "Error del servidor"
        }
      },
      
      "POST /api/robots/{robot_id}/asignaciones": {
        "description": "Actualiza las asignaciones de un robot (asignar/desasignar equipos)",
        "method": "POST",
        "pathParameters": {
          "robot_id": {
            "type": "integer",
            "required": true
          }
        },
        "requestBody": {
          "asignar_equipo_ids": {
            "type": "array[integer]",
            "required": true,
            "description": "Lista de IDs de equipos a asignar"
          },
          "desasignar_equipo_ids": {
            "type": "array[integer]",
            "required": true,
            "description": "Lista de IDs de equipos a desasignar"
          }
        },
        "businessRules": [
          "Las asignaciones manuales deben marcarse con Reservado=1",
          "El robot NO debe tener EsOnline=1 si se asignan equipos programados",
          "No se pueden desasignar equipos que estén en ejecución activa"
        ],
        "sideEffects": [
          "Asignaciones nuevas se marcan con Reservado=1 y AsignadoPor='WebApp'",
          "Desasignaciones solo aplican a asignaciones dinámicas (EsProgramado=0, Reservado variable)"
        ],
        "statusCodes": {
          "200": "Actualización exitosa",
          "404": "Robot no encontrado",
          "500": "Error del servidor"
        }
      }
    },
    
    "programaciones": {
      "GET /api/robots/{robot_id}/programaciones": {
        "description": "Obtiene todas las programaciones de un robot",
        "method": "GET",
        "pathParameters": {
          "robot_id": {
            "type": "integer",
            "required": true
          }
        },
        "responseSchema": [
          {
            "ProgramacionId": "integer",
            "RobotId": "integer",
            "TipoProgramacion": "string (Diaria|Semanal|Mensual|Especifica)",
            "HoraInicio": "string (HH:MM)",
            "DiasSemana": "string (opcional, ej: 'Lu,Ma,Mi')",
            "DiaDelMes": "integer (opcional, 1-31)",
            "FechaEspecifica": "string (opcional, YYYY-MM-DD)",
            "Tolerancia": "integer (minutos)",
            "Activo": "boolean",
            "FechaCreacion": "datetime",
            "FechaModificacion": "datetime",
            "Equipos": [
              {
                "EquipoId": "integer",
                "Equipo": "string"
              }
            ]
          }
        ],
        "statusCodes": {
          "200": "Éxito",
          "500": "Error del servidor"
        }
      },
      
      "POST /api/programaciones": {
        "description": "Crea una nueva programación para un robot",
        "method": "POST",
        "requestBody": {
          "RobotId": "integer (requerido)",
          "TipoProgramacion": "string (requerido: Diaria|Semanal|Mensual|Especifica)",
          "HoraInicio": "string (requerido, formato HH:MM)",
          "Tolerancia": "integer (requerido, 0-1440)",
          "Equipos": "array[integer] (requerido, mínimo 1 equipo)",
          "DiasSemana": "string (requerido si TipoProgramacion=Semanal)",
          "DiaDelMes": "integer (requerido si TipoProgramacion=Mensual, 1-31)",
          "FechaEspecifica": "string (requerido si TipoProgramacion=Especifica, formato YYYY-MM-DD)"
        },
        "validations": [
          "Robot debe existir y estar Activo=1",
          "Robot NO puede tener EsOnline=1",
          "Al menos un equipo debe estar disponible y activo",
          "Campos condicionales según TipoProgramacion"
        ],
        "sideEffects": [
          "Marca Robot.EsOnline=0",
          "Crea asignaciones con EsProgramado=1, ProgramacionId",
          "Establece Equipos.PermiteBalanceoDinamico=0 para equipos asignados"
        ],
        "storedProcedure": "dbo.CrearProgramacion",
        "statusCodes": {
          "200": "Programación creada exitosamente",
          "400": "Datos inválidos o violación de regla de negocio",
          "500": "Error del servidor"
        }
      },
      
      "PUT /api/programaciones/{programacion_id}": {
        "description": "Actualiza una programación existente",
        "method": "PUT",
        "pathParameters": {
          "programacion_id": {
            "type": "integer",
            "required": true
          }
        },
        "requestBody": "Mismo schema que POST /api/programaciones",
        "sideEffects": [
          "Desprograma equipos que ya no están en la lista (establece EsProgramado=0)",
          "Programa nuevos equipos (establece EsProgramado=1)",
          "Actualiza PermiteBalanceoDinamico según corresponda"
        ],
        "storedProcedure": "dbo.ActualizarProgramacionCompleta",
        "statusCodes": {
          "200": "Programación actualizada exitosamente",
          "400": "Datos inválidos",
          "404": "Programación no encontrada",
          "500": "Error del servidor"
        }
      },
      
      "DELETE /api/robots/{robot_id}/programaciones/{programacion_id}": {
        "description": "Elimina una programación y limpia sus asignaciones",
        "method": "DELETE",
        "pathParameters": {
          "robot_id": {
            "type": "integer",
            "required": true
          },
          "programacion_id": {
            "type": "integer",
            "required": true
          }
        },
        "sideEffects": [
          "Elimina el registro de Programaciones",
          "Elimina asignaciones con EsProgramado=1 y ProgramacionId correspondiente",
          "Establece PermiteBalanceoDinamico=1 para equipos que quedan libres"
        ],
        "storedProcedure": "dbo.EliminarProgramacionCompleta",
        "statusCodes": {
          "204": "Eliminación exitosa (sin contenido)",
          "500": "Error del servidor"
        }
      }
    },
    
    "pools": {
      "GET /api/pools": {
        "description": "Obtiene la lista completa de pools con contadores de recursos",
        "method": "GET",
        "responseSchema": [
          {
            "PoolId": "integer",
            "Nombre": "string",
            "Descripcion": "string",
            "Activo": "boolean",
            "CantidadRobots": "integer",
            "CantidadEquipos": "integer"
          }
        ],
        "storedProcedure": "dbo.ListarPools",
        "statusCodes": {
          "200": "Éxito",
          "500": "Error del servidor"
        }
      },
      
      "POST /api/pools": {
        "description": "Crea un nuevo pool de recursos",
        "method": "POST",
        "requestBody": {
          "Nombre": {
            "type": "string",
            "required": true,
            "maxLength": 100,
            "description": "Nombre único del pool"
          },
          "Descripcion": {
            "type": "string",
            "required": false,
            "maxLength": 500,
            "description": "Descripción del pool"
          }
        },
        "validations": [
          "Nombre no puede estar vacío",
          "Nombre debe ser único en el sistema"
        ],
        "responseSchema": {
          "PoolId": "integer",
          "Nombre": "string",
          "Descripcion": "string",
          "Activo": "boolean",
          "CantidadRobots": 0,
          "CantidadEquipos": 0
        },
        "storedProcedure": "dbo.CrearPool",
        "statusCodes": {
          "201": "Pool creado exitosamente",
          "409": "Nombre duplicado",
          "500": "Error del servidor"
        }
      },
      
      "PUT /api/pools/{pool_id}": {
        "description": "Actualiza un pool existente",
        "method": "PUT",
        "pathParameters": {
          "pool_id": {
            "type": "integer",
            "required": true
          }
        },
        "requestBody": {
          "Nombre": "string (requerido, único)",
          "Descripcion": "string (opcional)"
        },
        "validations": [
          "Nombre no puede estar vacío",
          "Nombre debe ser único (excepto el pool actual)"
        ],
        "storedProcedure": "dbo.ActualizarPool",
        "statusCodes": {
          "200": "Pool actualizado exitosamente",
          "404": "Pool no encontrado",
          "409": "Nombre duplicado",
          "500": "Error del servidor"
        }
      },
      
      "DELETE /api/pools/{pool_id}": {
        "description": "Elimina un pool de recursos",
        "method": "DELETE",
        "pathParameters": {
          "pool_id": {
            "type": "integer",
            "required": true
          }
        },
        "confirmationRequired": true,
        "sideEffects": [
          "Establece PoolId=NULL en Robots asignados al pool",
          "Establece PoolId=NULL en Equipos asignados al pool",
          "Los recursos vuelven al Pool General"
        ],
        "storedProcedure": "dbo.EliminarPool",
        "statusCodes": {
          "204": "Pool eliminado exitosamente (sin contenido)",
          "404": "Pool no encontrado",
          "500": "Error del servidor"
        }
      },
      
      "GET /api/pools/{pool_id}/asignaciones": {
        "description": "Obtiene recursos asignados y disponibles para un pool",
        "method": "GET",
        "pathParameters": {
          "pool_id": {
            "type": "integer",
            "required": true
          }
        },
        "responseSchema": {
          "assigned": [
            {
              "ID": "integer",
              "Nombre": "string",
              "Tipo": "string (Robot|Equipo)"
            }
          ],
          "available": [
            {
              "ID": "integer",
              "Nombre": "string",
              "Tipo": "string (Robot|Equipo)"
            }
          ]
        },
        "storedProcedure": "dbo.ObtenerRecursosParaPool",
        "statusCodes": {
          "200": "Éxito",
          "500": "Error del servidor"
        }
      },
      
      "PUT /api/pools/{pool_id}/asignaciones": {
        "description": "Actualiza las asignaciones de un pool (sobrescribe)",
        "method": "PUT",
        "pathParameters": {
          "pool_id": {
            "type": "integer",
            "required": true
          }
        },
        "requestBody": {
          "robot_ids": {
            "type": "array[integer]",
            "required": true,
            "description": "Lista completa de IDs de robots a asignar al pool"
          },
          "team_ids": {
            "type": "array[integer]",
            "required": true,
            "description": "Lista completa de IDs de equipos a asignar al pool"
          }
        },
        "businessLogic": [
          "Primero desasigna todos los recursos del pool (PoolId=NULL)",
          "Luego asigna los nuevos recursos (PoolId=@PoolId)"
        ],
        "storedProcedure": "dbo.AsignarRecursosAPool",
        "statusCodes": {
          "200": "Asignaciones actualizadas exitosamente",
          "404": "Pool no encontrado",
          "500": "Error del servidor"
        }
      }
    },
    
    "sync": {
      "POST /api/sync": {
        "description": "Dispara el proceso de sincronización manual con A360",
        "method": "POST",
        "authentication": "No requerida (endpoint interno)",
        "asyncOperation": true,
        "process": [
          "1. Conecta con A360 Control Room API",
          "2. Obtiene devices, usuarios y robots en paralelo (asyncio.gather)",
          "3. Cruza datos: asigna licencia a equipos según usuario",
          "4. Elimina duplicados de la respuesta de A360",
          "5. Llama a MergeEquipos y MergeRobots (TVPs)",
          "6. Retorna resumen de sincronización"
        ],
        "responseSchema": {
          "robots_sincronizados": "integer",
          "equipos_sincronizados": "integer"
        },
        "errorHandling": [
          "Captura errores de conexión con A360",
          "Registra errores en logs del backend",
          "Retorna 500 con mensaje descriptivo"
        ],
        "statusCodes": {
          "200": "Sincronización completada exitosamente",
          "500": "Error durante la sincronización"
        }
      }
    }
  },
  
  "businessRules": {
    "rule_001": {
      "id": "BR-001",
      "title": "No programar robots Online",
      "description": "No es posible crear o activar una programación para un robot donde EsOnline=1",
      "validation": "Antes de crear/actualizar una programación, verificar que Robot.EsOnline=0",
      "enforcement": "Backend (endpoint + stored procedure)",
      "errorMessage": "No se puede programar un robot que está en modo Online (EsOnline=1). Desactive el modo Online primero."
    },
    
    "rule_002": {
      "id": "BR-002",
      "title": "Asignaciones programadas marcan EsProgramado=1 y EsOnline=0",
      "description": "Cuando se asigna un equipo a un robot programado, debe marcarse EsProgramado=1 y el robot debe tener EsOnline=0",
      "validation": "Stored procedure CrearProgramacion/ActualizarProgramacionCompleta validan y establecen estos valores",
      "enforcement": "Backend (stored procedures)",
      "sideEffect": "PermiteBalanceoDinamico=0 para equipos programados"
    },
    
    "rule_003": {
      "id": "BR-003",
      "title": "Asignaciones manuales marcan Reservado=1",
      "description": "Las asignaciones realizadas desde la interfaz web deben marcarse con Reservado=1 para diferenciarlas de las dinámicas del balanceador",
      "validation": "Endpoint POST /api/robots/{id}/asignaciones establece Reservado=1 y AsignadoPor='WebApp'",
      "enforcement": "Backend (database.py - update_asignaciones_robot)",
      "purpose": "Evita que el balanceador desasigne equipos reservados manualmente"
    },
    
    "rule_004": {
      "id": "BR-004",
      "title": "Solicitar confirmación antes de operaciones críticas",
      "description": "Antes de hacer una Asignación/Desasignación, Eliminar/Modificar un Pool, o Eliminar una Programación, debe solicitarse confirmación al usuario",
      "validation": "Frontend muestra ConfirmationModal antes de llamar al endpoint",
      "enforcement": "Frontend (componentes con modales de confirmación)",
      "userExperience": "Mejora prevención de errores humanos"
    },
    
    "rule_005": {
      "id": "BR-005",
      "title": "Equipos programados no permiten balanceo dinámico",
      "description": "Un equipo con asignación programada (EsProgramado=1) debe tener PermiteBalanceoDinamico=0",
      "validation": "Stored procedures de programación establecen este valor automáticamente",
      "enforcement": "Backend (stored procedures)",
      "purpose": "Evita conflictos entre programaciones y balanceo dinámico"
    },
    
    "rule_006": {
      "id": "BR-006",
      "title": "No desasignar equipos en ejecución",
      "description": "No se debe permitir desasignar un equipo que está ejecutando un robot actualmente",
      "validation": "Consultar tabla Ejecuciones para verificar estados activos antes de desasignar",
      "enforcement": "Backend (lógica en update_asignaciones_robot)",
      "implementation": "Verificar que no existe ejecución con Estado IN ('PENDING_EXECUTION', 'DEPLOYED', 'RUNNING', 'UPDATE', 'RUN_PAUSED', 'QUEUED')"
    },
    
    "rule_007": {
      "id": "BR-007",
      "title": "Validar coherencia de programaciones según tipo",
      "description": "Cada tipo de programación requiere campos específicos obligatorios",
      "validations": {
        "Diaria": "Solo HoraInicio y Tolerancia",
        "Semanal": "HoraInicio, Tolerancia y DiasSemana (formato: 'Lu,Ma,Mi,Ju,Vi,Sa,Do')",
        "Mensual": "HoraInicio, Tolerancia y DiaDelMes (1-31)",
        "Especifica": "HoraInicio, Tolerancia y FechaEspecifica (formato: YYYY-MM-DD)"
      },
      "enforcement": "Frontend (validación en formulario) + Backend (Pydantic schema)"
    },
    
    "rule_008": {
      "id": "BR-008",
      "title": "Un pool no puede tener nombre duplicado",
      "description": "El nombre de un pool debe ser único en el sistema",
      "validation": "Stored procedure CrearPool y ActualizarPool validan unicidad",
      "enforcement": "Backend (stored procedures con RAISERROR)",
      "errorMessage": "Ya existe un pool con el nombre '{nombre}'."
    },
    
    "rule_009": {
      "id": "BR-009",
      "title": "Limitar valores de configuración de robots",
      "description": "Los valores de configuración de robots deben estar en rangos válidos",
      "validations": {
        "MinEquipos": ">= 0",
        "MaxEquipos": ">= MinEquipos OR = -1 (ilimitado)",
        "PrioridadBalanceo": "0 <= x <= 100",
        "TicketsPorEquipoAdicional": "> 0",
        "Tolerancia": "0 <= x <= 1440 (24 horas en minutos)"
      },
      "enforcement": "Frontend (validación en formulario) + Backend (Pydantic schema)"
    },
    
    "rule_010": {
      "id": "BR-010",
      "title": "Al menos un equipo debe estar asignado a una programación",
      "description": "Una programación sin equipos asignados no tiene sentido operacional",
      "validation": "Verificar que array 'Equipos' tenga al menos 1 elemento",
      "enforcement": "Frontend (deshabilitar botón Guardar si lista vacía) + Backend (validación en create_new_schedule)"
    }
  },
  
  "frontendArchitecture": {
    "componentStructure": {
      "principle": "Componentes funcionales con hooks para estado y efectos secundarios",
      "stateManagement": "useState, useEffect, useContext (sin Redux/MobX)",
      "customHooks": {
        "use_robots": "Gestión completa de estado para robots (lista, filtros, paginación, ordenamiento)",
        "use_pools_management": "Gestión completa de estado para pools (CRUD completo)",
        "use_debounced_value": "Debouncing para inputs de búsqueda"
      }
    },
    
    "routing": {
      "library": "reactpy_router",
      "routes": [
        {
          "path": "/",
          "component": "DashboardWithRouting",
          "description": "Dashboard principal de gestión de robots"
        },
        {
          "path": "/pools",
          "component": "PoolsWithRouting",
          "description": "Gestión de pools de recursos"
        },
        {
          "path": "{404:any}",
          "component": "NotFoundWithRouting",
          "description": "Página de error 404"
        }
      ]
    },
    
    "notificationSystem": {
      "implementation": "Context API (NotificationContext)",
      "component": "ToastContainer",
      "types": ["success", "error", "warning", "info"],
      "autoDismiss": "5 segundos",
      "features": [
        "Animación de entrada (slideIn)",
        "Cierre manual con botón X",
        "Stack de múltiples notificaciones",
        "Estilos diferenciados por tipo"
      ]
    },
    
    "responsiveDesign": {
      "framework": "Pico.css",
      "breakpoints": {
        "mobile": "< 1024px",
        "desktop": ">= 1024px"
      },
      "strategy": {
        "mobile": "Vista de tarjetas (cards), panel de controles colapsable",
        "desktop": "Vista de tabla, controles siempre visibles"
      },
      "implementation": "CSS Grid con grid-template-areas para layouts flexibles"
    },
    
    "apiClientPattern": {
      "client": "httpx.AsyncClient",
      "singleton": "get_api_client() retorna instancia única",
      "errorHandling": {
        "retries": "3 intentos con exponential backoff",
        "exceptions": "APIException, ValidationException",
        "userFeedback": "Notificaciones toast automáticas"
      },
      "methods": [
        "get_robots(params)",
        "update_robot(id, data)",
        "update_robot_status(id, status)",
        "get_robot_assignments(id)",
        "update_robot_assignments(id, assign_ids, unassign_ids)",
        "get_robot_schedules(id)",
        "create_schedule(data)",
        "update_schedule(id, data)",
        "delete_schedule(robot_id, schedule_id)",
        "get_pools()",
        "create_pool(data)",
        "update_pool(id, data)",
        "delete_pool(id)",
        "get_pool_assignments(id)",
        "update_pool_assignments(id, robot_ids, device_ids)",
        "trigger_sync()"
      ]
    }
  },
  
  "testingStrategy": {
    "gherkinScenarios": {
      "location": "web_feature.txt (proporcionado)",
      "coverage": [
        "Visualización y filtrado de robots",
        "Sincronización manual con A360",
        "Edición de robots",
        "Gestión de asignaciones manuales",
        "Creación de programaciones",
        "CRUD de pools",
        "Asignación de recursos a pools"
      ],
      "extensions": [
        "Agregar escenarios de error (validaciones fallidas)",
        "Agregar escenarios de confirmación de usuario",
        "Agregar escenarios de concurrencia (múltiples usuarios)"
      ]
    },
    
    "additionalScenarios": [
      {
        "feature": "Validación de Reglas de Negocio",
        "scenario": "Intentar programar un robot Online",
        "given": "Un robot con EsOnline=1",
        "when": "El usuario intenta crear una programación",
        "then": "El sistema muestra un error y no permite la creación"
      },
      {
        "feature": "Sincronización con A360",
        "scenario": "Manejo de duplicados de la API",
        "given": "A360 retorna equipos duplicados",
        "when": "Se ejecuta la sincronización",
        "then": "El sistema elimina duplicados antes de hacer MERGE"
      },
      {
        "feature": "Gestión de Asignaciones",
        "scenario": "Prevenir desasignación de equipo en ejecución",
        "given": "Un equipo está ejecutando un robot",
        "when": "El usuario intenta desasignar el equipo",
        "then": "El sistema rechaza la operación con mensaje explicativo"
      }
    ]
  },
  
  "suggestedImprovements": {
    "dashboards": [
      {
        "name": "Dashboard de Performance del Balanceador",
        "description": "Visualización en tiempo real del rendimiento del servicio Balanceador",
        "dataSource": "Vista EstadoBalanceadorTiempoReal + Tabla HistoricoBalanceo",
        "metrics": [
          "Tasa de utilización de robots/VMs (%)",
          "Tiempo promedio de respuesta del balanceador (segundos)",
          "Cantidad de asignaciones/desasignaciones por hora",
          "Conflictos de programación detectados",
          "Robots bloqueados por EsOnline=1",
          "Historial de asignaciones manual vs automática",
          "Detección de thrashing (CoolingManager)"
        ],
        "visualizations": [
          "Gráfico de líneas: Evolución de asignaciones en el tiempo",
          "Gráfico de barras: Equipos asignados por robot",
          "Tabla: Últimas 20 decisiones del balanceador con justificación",
          "Indicadores KPI: Total equipos libres, Total robots activos, Promedio tickets por robot"
        ],
        "implementation": "Nueva ruta /balanceador con componente BalanceadorDashboard"
      },
      {
        "name": "Dashboard de Callbacks y Conciliador",
        "description": "Análisis de rendimiento del sistema de callbacks vs conciliador",
        "dataSource": "Vista AnalisisRendimientoCallbacks + SP ObtenerDashboardCallbacks",
        "metrics": [
          "Porcentaje de callbacks exitosos vs conciliador",
          "Latencia promedio de actualización (minutos)",
          "Callbacks fallidos por período",
          "Ejecuciones en estado UNKNOWN",
          "Distribución de rendimiento (Excelente/Bueno/Regular/Deficiente)",
          "Análisis por robot",
          "Tendencia diaria de callbacks"
        ],
        "implementation": "Nueva ruta /callbacks con componente CallbacksDashboard"
      }
    ],
    
    "features": [
      {
        "name": "Historial de Cambios (Audit Log)",
        "description": "Registro de todas las operaciones CRUD realizadas desde la interfaz web",
        "implementation": {
          "database": "Nueva tabla AuditLog con columnas: Id, Timestamp, Usuario, Operacion, EntidadTipo, EntidadId, ValoresAnteriores (JSON), ValoresNuevos (JSON)",
          "backend": "Decorator o middleware que registre automáticamente cambios",
          "frontend": "Modal o página dedicada para visualizar historial por entidad"
        },
        "priority": "High"
      },
      {
        "name": "Notificaciones en Tiempo Real",
        "description": "Alertas push cuando ocurren eventos importantes (sincronización completa, errores del balanceador, etc.)",
        "implementation": {
          "technology": "WebSockets (FastAPI con websockets) o Server-Sent Events",
          "events": ["sync_completed", "balancer_error", "robot_execution_failed", "pool_modified"]
        },
        "priority": "Medium"
      },
      {
        "name": "Exportación de Datos",
        "description": "Permitir exportar listas de robots, programaciones y pools a CSV/Excel",
        "implementation": {
          "backend": "Endpoints GET con parámetro ?format=csv",
          "frontend": "Botón 'Exportar' en cada vista de lista"
        },
        "priority": "Low"
      },
      {
        "name": "Búsqueda Avanzada y Filtros Guardados",
        "description": "Permitir guardar combinaciones de filtros frecuentemente usados",
        "implementation": {
          "database": "Tabla FiltrosGuardados (Usuario, Nombre, Filtros JSON)",
          "frontend": "Dropdown de filtros guardados + botón 'Guardar filtro actual'"
        },
        "priority": "Low"
      },
      {
        "name": "Gestión de Usuarios y Permisos",
        "description": "Sistema de autenticación y control de acceso basado en roles",
        "roles": ["Admin", "Operator", "Viewer"],
        "permissions": {
          "Admin": "CRUD completo en todas las entidades",
          "Operator": "Lectura y modificación de asignaciones/programaciones",
          "Viewer": "Solo lectura"
        },
        "implementation": {
          "backend": "FastAPI con OAuth2/JWT",
          "frontend": "Login page + manejo de tokens en api_client"
        },
        "priority": "High (para producción)"
      }
    ],
    
    "technicalImprovements": [
      {
        "area": "Performance",
        "suggestion": "Implementar caché en el backend para consultas frecuentes (lista de robots, pools)",
        "implementation": "FastAPI con @lru_cache o Redis"
      },
      {
        "area": "Error Handling",
        "suggestion": "Mejorar mensajes de error del backend para ser más descriptivos",
        "implementation": "Custom exception handlers en FastAPI que retornen mensajes legibles"
      },
      {
        "area": "Validation",
        "suggestion": "Centralizar validaciones complejas en funciones reutilizables",
        "implementation": "Módulo utils/validation.py con funciones como validate_robot_config(), validate_schedule_data()"
      },
      {
        "area": "Testing",
        "suggestion": "Implementar tests unitarios para servicios de backend",
        "implementation": "pytest con fixtures para DatabaseConnector mock"
      },
      {
        "area": "Documentation",
        "suggestion": "Generar documentación automática de la API",
        "implementation": "FastAPI auto-genera docs en /docs (Swagger UI) y /redoc"
      }
    ]
  },
  
  "deploymentConfiguration": {
    "backend": {
      "server": "Uvicorn (ASGI server)",
      "host": "0.0.0.0",
      "port": 8000,
      "workers": "Configurable (default: 1 para desarrollo)",
      "reload": "True en desarrollo, False en producción",
      "environmentVariables": [
        "INTERFAZ_WEB_HOST",
        "INTERFAZ_WEB_PORT",
        "INTERFAZ_WEB_DEBUG",
        "SQL_SAM_HOST",
        "SQL_SAM_DB_NAME",
        "SQL_SAM_UID",
        "SQL_SAM_PWD",
        "AA_CR_URL",
        "AA_CR_USER",
        "AA_CR_PWD (opcional)",
        "AA_CR_API_KEY"
      ]
    },
    
    "frontend": {
      "integration": "ReactPy integrado en FastAPI",
      "staticFiles": "/static/ (CSS, JavaScript, assets)",
      "templates": "No usa templates tradicionales (componentes ReactPy)",
      "bundling": "No requiere webpack/npm (Python puro)"
    },
    
    "production": {
      "serviceManager": "NSSM (Non-Sucking Service Manager) en Windows",
      "serviceName": "SAM-InterfazWeb",
      "startCommand": "python.exe C:\\path\\to\\SAM\\src\\web\\run_interfaz_web.py",
      "workingDirectory": "C:\\path\\to\\SAM",
      "logging": {
        "directory": "C:/RPA/Logs/SAM",
        "file": "sam_interfaz_web.log",
        "rotation": "Diaria (midnight)",
        "retention": "7 días"
      }
    }
  },
  
  "securityConsiderations": {
    "authentication": {
      "current": "No implementado (acceso sin restricciones)",
      "recommended": "OAuth2 con JWT tokens o Active Directory integration",
      "priority": "High para entornos de producción"
    },
    
    "authorization": {
      "current": "No implementado",
      "recommended": "RBAC (Role-Based Access Control) con roles Admin/Operator/Viewer"
    },
    
    "inputValidation": {
      "backend": "Pydantic schemas validan todos los inputs",
      "frontend": "Validación en formularios antes de enviar al backend",
      "sqlInjection": "Mitigado usando parámetros en consultas (DatabaseConnector)",
      "xss": "ReactPy escapa automáticamente contenido HTML"
    },
    
    "apiSecurity": {
      "cors": "Configurar CORS en producción para dominios específicos",
      "rateLimiting": "Recomendado implementar para prevenir abuse",
      "https": "Requerido en producción (usar reverse proxy como nginx)"
    },
    
    "dataProtection": {
      "passwords": "No almacenar contraseñas en texto plano (usar bcrypt/argon2)",
      "sensitiveData": "Logs no deben contener credenciales o tokens",
      "auditTrail": "Implementar logging de operaciones críticas"
    }
  },
  
  "developmentWorkflow": {
    "setupInstructions": [
      "1. Clonar repositorio y crear entorno virtual Python 3.8+",
      "2. Instalar dependencias: pip install -r requirements.txt",
      "3. Configurar archivo .env con variables de entorno requeridas",
      "4. Ejecutar script SAM.sql en SQL Server para crear BD",
      "5. Iniciar backend: python src/web/run_interfaz_web.py",
      "6. Acceder a http://localhost:8000"
    ],
    
    "codingStandards": {
      "python": {
        "style": "PEP 8",
        "formatter": "black (recomendado)",
        "linter": "flake8 o pylint",
        "typeHints": "Usar type hints en funciones públicas",
        "docstrings": "Google style para funciones complejas"
      },
      "components": {
        "naming": "PascalCase para componentes (ej: RobotDashboard)",
        "props": "snake_case para props (ej: on_save_success)",
        "structure": "Un componente por archivo para componentes complejos",
        "comments": "Comentar lógica de negocio compleja, no código obvio"
      }
    },
    
    "gitWorkflow": {
      "branches": {
        "main": "Código estable en producción",
        "develop": "Código en desarrollo (integración continua)",
        "feature/*": "Nuevas funcionalidades",
        "bugfix/*": "Corrección de bugs",
        "hotfix/*": "Correcciones urgentes para producción"
      },
      "commits": {
        "format": "type(scope): message",
        "types": ["feat", "fix", "refactor", "docs", "test", "chore"],
        "example": "feat(pools): add delete confirmation modal"
      },
      "pullRequests": {
        "required": true,
        "reviewers": "Mínimo 1 revisor",
        "checks": "Linter + tests automatizados"
      }
    }
  },
  
  "aiDevelopmentPrompts": {
    "promptForNewFeature": "Estoy trabajando en el proyecto SAM (Sistema Automático de Robots). Necesito implementar [DESCRIPCIÓN DE LA FEATURE]. Sigue estrictamente:\n\n1. La arquitectura definida en este documento (FastAPI + ReactPy + Pico.css)\n2. Los patrones de componentes existentes (hooks, api_client, modales)\n3. Las reglas de negocio documentadas (especialmente BR-001 a BR-010)\n4. La estructura de directorios actual (backend/api.py, frontend/features/)\n5. Usa Stored Procedures para lógica compleja de BD\n6. Implementa validaciones tanto en frontend como backend\n7. Añade notificaciones toast para feedback al usuario\n8. Sigue el patrón de confirmación para operaciones críticas\n\nProporciona:\n- Código completo del endpoint (si aplica)\n- Código completo del componente ReactPy\n- Modificaciones necesarias en schemas.py\n- Query/SP de base de datos (si aplica)\n- Casos de prueba Gherkin",
    
    "promptForBugfix": "Estoy trabajando en el proyecto SAM. He detectado el siguiente bug: [DESCRIPCIÓN DEL BUG].\n\nContexto:\n- Endpoint/Componente afectado: [NOMBRE]\n- Comportamiento esperado: [DESCRIPCIÓN]\n- Comportamiento actual: [DESCRIPCIÓN]\n- Logs/Errores: [SI APLICA]\n\nAnaliza el código según las especificaciones del proyecto y proporciona:\n1. Diagnóstico del problema\n2. Solución propuesta con código corregido\n3. Validaciones adicionales para prevenir el bug\n4. Test case para verificar la corrección",
    
    "promptForRefactoring": "Estoy refactorizando el código del proyecto SAM. Necesito mejorar [COMPONENTE/MÓDULO].\n\nObjetivos:\n- Mejorar legibilidad/mantenibilidad\n- Seguir patrones del proyecto (DI, separation of concerns)\n- Optimizar performance (si aplica)\n- Mantener compatibilidad con código existente\n\nProporciona:\n1. Análisis del código actual (code smells, anti-patterns)\n2. Código refactorizado siguiendo best practices\n3. Justificación de los cambios\n4. Impacto en otros módulos (si aplica)",
    
    "promptForCodeReview": "Revisa el siguiente código del proyecto SAM según las especificaciones técnicas:\n\n[CÓDIGO]\n\nVerifica:\n1. Cumplimiento de arquitectura (layered, DI, separation)\n2. Adherencia a reglas de negocio (BR-001 a BR-010)\n3. Validaciones de entrada (frontend y backend)\n4. Manejo de errores y feedback al usuario\n5. Consistencia con patrones existentes\n6. Seguridad (SQL injection, XSS, validaciones)\n7. Performance (N+1 queries, uso de índices)\n8. Documentación (docstrings, comentarios)\n\nProporciona feedback constructivo con ejemplos de mejora.",
    
    "promptForDatabaseDesign": "Necesito diseñar/modificar la estructura de base de datos para [FEATURE] en el proyecto SAM.\n\nRequerimientos:\n- Integración con modelo existente (Robots, Equipos, Asignaciones, etc.)\n- Stored Procedures para lógica compleja\n- Índices para optimizar consultas\n- Foreign keys y constraints apropiados\n- Triggers si es necesario\n\nProporciona:\n1. Script DDL completo (CREATE TABLE, ALTER TABLE)\n2. Stored Procedures necesarios\n3. Índices recomendados\n4. Diagrama ER (descripción textual)\n5. Consultas de ejemplo para operaciones comunes",
    
    "promptForTesting": "Necesito crear tests para [COMPONENTE/ENDPOINT] del proyecto SAM.\n\nContexto:\n- Funcionalidad: [DESCRIPCIÓN]\n- Reglas de negocio aplicables: [BR-XXX]\n- Dependencias: [LISTA]\n\nProporciona:\n1. Casos de prueba Gherkin (Given/When/Then)\n2. Tests unitarios (pytest) si es backend\n3. Tests de integración para flujos completos\n4. Casos edge y manejo de errores\n5. Datos de prueba (fixtures)"
  },
  
  "commonPitfalls": {
    "pitfall_001": {
      "issue": "No validar EsOnline antes de crear programaciones",
      "impact": "Violación de BR-001, inconsistencia de datos",
      "solution": "Siempre verificar Robot.EsOnline=0 antes de INSERT en Programaciones"
    },
    
    "pitfall_002": {
      "issue": "No marcar Reservado=1 en asignaciones manuales",
      "impact": "El balanceador puede desasignar equipos que fueron asignados manualmente",
      "solution": "Establecer Reservado=1 y AsignadoPor='WebApp' en todas las asignaciones desde la interfaz"
    },
    
    "pitfall_003": {
      "issue": "No actualizar PermiteBalanceoDinamico al programar/desprogramar",
      "impact": "Conflictos entre programaciones y balanceo dinámico",
      "solution": "Los SPs de programación deben gestionar este campo automáticamente"
    },
    
    "pitfall_004": {
      "issue": "No solicitar confirmación para operaciones destructivas",
      "impact": "Usuario puede eliminar datos accidentalmente",
      "solution": "Usar ConfirmationModal antes de DELETE o modificaciones masivas"
    },
    
    "pitfall_005": {
      "issue": "No manejar duplicados de la API de A360",
      "impact": "Errores de PRIMARY KEY durante sincronización",
      "solution": "Usar dict para eliminar duplicados antes de llamar a MergeEquipos/MergeRobots"
    },
    
    "pitfall_006": {
      "issue": "No cerrar el ApiClient después de usarlo",
      "impact": "Memory leaks y conexiones abiertas",
      "solution": "Usar singleton get_api_client() y cerrar con await client.close() si es necesario"
    },
    
    "pitfall_007": {
      "issue": "Olvidar actualizar total_count en paginación",
      "impact": "Paginación incorrecta en el frontend",
      "solution": "Siempre hacer COUNT(*) antes de la consulta paginada"
    },
    
    "pitfall_008": {
      "issue": "No validar campos condicionales según TipoProgramacion",
      "impact": "Datos inconsistentes en tabla Programaciones",
      "solution": "Validar en frontend y backend que campos requeridos estén presentes según tipo"
    }
  },
  
  "troubleshooting": {
    "issue_001": {
      "symptom": "Error 500 al crear programación",
      "possibleCauses": [
        "Robot tiene EsOnline=1",
        "Lista de Equipos está vacía",
        "Campos condicionales faltantes (DiasSemana, etc.)",
        "Error de conexión con base de datos"
      ],
      "diagnosticSteps": [
        "Verificar logs del backend (sam_interfaz_web.log)",
        "Verificar estado del robot: SELECT EsOnline FROM Robots WHERE RobotId=?",
        "Validar payload enviado desde frontend",
        "Verificar conectividad con SQL Server"
      ]
    },
    
    "issue_002": {
      "symptom": "Sincronización con A360 falla",
      "possibleCauses": [
        "Credenciales incorrectas (AA_CR_USER, AA_CR_PWD)",
        "URL del Control Room incorrecta",
        "Token expirado o API key inválida",
        "Control Room no accesible (red/firewall)"
      ],
      "diagnosticSteps": [
        "Verificar variables de entorno AA_*",
        "Probar conectividad: curl -X GET AA_CR_URL/v1/authentication/token",
        "Revisar logs para mensaje de error específico",
        "Verificar certificados SSL si AA_VERIFY_SSL=True"
      ]
    },
    
    "issue_003": {
      "symptom": "Asignaciones no se guardan",
      "possibleCauses": [
        "Robot está en modo Online (EsOnline=1)",
        "Equipos ya están asignados a otro robot",
        "Violación de constraint UNIQUE (RobotId, EquipoId)"
      ],
      "diagnosticSteps": [
        "Verificar estado del robot",
        "Consultar asignaciones existentes: SELECT * FROM Asignaciones WHERE EquipoId IN (...)",
        "Revisar logs del backend para excepciones SQL"
      ]
    },
    
    "issue_004": {
      "symptom": "Frontend muestra datos desactualizados",
      "possibleCauses": [
        "No se llama a refresh() después de operaciones CRUD",
        "Caché del navegador",
        "Error en la lógica de actualización de estado"
      ],
      "diagnosticSteps": [
        "Verificar que on_save_success() llama a refresh()",
        "Limpiar caché del navegador (Ctrl+Shift+R)",
        "Inspeccionar red en DevTools para ver responses"
      ]
    },
    
    "issue_005": {
      "symptom": "Error al eliminar pool con recursos asignados",
      "possibleCauses": [
        "SP EliminarPool tiene bug",
        "Foreign key constraint no permite DELETE"
      ],
      "diagnosticSteps": [
        "Verificar implementación del SP: debe hacer UPDATE ... SET PoolId=NULL antes de DELETE",
        "Consultar recursos asignados: SELECT * FROM Robots WHERE PoolId=? UNION SELECT * FROM Equipos WHERE PoolId=?"
      ]
    }
  },
  
  "glossary": {
    "terms": [
      {
        "term": "Robot",
        "definition": "Proceso automatizado (taskbot) de RPA configurado en Automation Anywhere A360"
      },
      {
        "term": "Equipo",
        "definition": "Máquina virtual (VM) o dispositivo físico donde se ejecutan los robots"
      },
      {
        "term": "Asignación",
        "definition": "Relación entre un robot y un equipo que indica en qué VM puede ejecutarse el robot"
      },
      {
        "term": "Asignación Dinámica",
        "definition": "Asignación gestionada automáticamente por el servicio Balanceador (EsProgramado=0, Reservado=0)"
      },
      {
        "term": "Asignación Programada",
        "definition": "Asignación asociada a una programación específica (EsProgramado=1)"
      },
      {
        "term": "Asignación Manual/Reservada",
        "definition": "Asignación realizada manualmente desde la interfaz web (Reservado=1)"
      },
      {
        "term": "Pool",
        "definition": "Agrupación lógica de robots y equipos para segmentar recursos"
      },
      {
        "term": "Pool General",
        "definition": "Pool por defecto para recursos no asignados a ningún pool específico (PoolId=NULL)"
      },
      {
        "term": "Programación",
        "definition": "Configuración de ejecución recurrente para un robot (Diaria, Semanal, Mensual, Específica)"
      },
      {
        "term": "EsOnline",
        "definition": "Flag que indica si un robot ejecuta a demanda (Online=1) o por programación (Online=0)"
      },
      {
        "term": "PermiteBalanceoDinamico",
        "definition": "Flag que indica si un equipo puede ser asignado automáticamente por el balanceador"
      },
      {
        "term": "Control Room",
        "definition": "Componente central de Automation Anywhere A360 que gestiona robots y equipos"
      },
      {
        "term": "TVP (Table-Valued Parameter)",
        "definition": "Parámetro de SQL Server que permite pasar tablas completas a stored procedures"
      },
      {
        "term": "Stored Procedure (SP)",
        "definition": "Rutina almacenada en la base de datos que encapsula lógica de negocio compleja"
      },
      {
        "term": "Merge",
        "definition": "Operación SQL que combina INSERT y UPDATE (sincronización de datos)"
      },
      {
        "term": "Toast",
        "definition": "Notificación temporal que aparece en la esquina de la pantalla para dar feedback al usuario"
      },
      {
        "term": "Hook",
        "definition": "Función de ReactPy que permite usar estado y efectos en componentes funcionales"
      },
      {
        "term": "Dependency Injection (DI)",
        "definition": "Patrón de diseño donde las dependencias se pasan desde fuera en lugar de crearlas internamente"
      }
    ]
  },
  
  "versionHistory": {
    "v2.0": {
      "date": "2025-01-03",
      "changes": [
        "Documento inicial completo con arquitectura, endpoints, modelo de datos",
        "Reglas de negocio documentadas (BR-001 a BR-010)",
        "Prompts para IA añadidos",
        "Mejoras sugeridas (dashboards, features, technical)",
        "Sección de troubleshooting y common pitfalls",
        "Glosario de términos"
      ],
      "author": "AI Assistant"
    }
  },
  
  "references": {
    "documentation": [
      "FastAPI Documentation: https://fastapi.tiangolo.com/",
      "ReactPy Documentation: https://reactpy.dev/",
      "Pico.css Documentation: https://picocss.com/",
      "Automation Anywhere A360 API: https://docs.automationanywhere.com/",
      "SQL Server T-SQL Reference: https://docs.microsoft.com/en-us/sql/t-sql/"
    ],
    
    "projectFiles": [
      "Guia de Arquitectura y Desarrollo.json",
      "README.md",
      "SAM.sql",
      "web_feature.txt (Gherkin scenarios)",
      "balanceador.txt (Gherkin scenarios)"
    ]
  },
  
  "conclusionAndNextSteps": {
    "summary": "Este documento proporciona una especificación técnica completa del servicio web de SAM, incluyendo arquitectura, endpoints REST, modelo de datos, reglas de negocio, patrones de desarrollo y prompts para asistentes de IA. Está diseñado para ser utilizado como referencia única durante el desarrollo, mantenimiento y extensión del sistema.",
    
    "priorityImplementations": [
      {
        "priority": "P0 - Critical",
        "tasks": [
          "Implementar validación de BR-001 (no programar robots Online) en backend",
          "Asegurar que todas las asignaciones manuales marquen Reservado=1",
          "Implementar confirmación de usuario para operaciones destructivas"
        ]
      },
      {
        "priority": "P1 - High",
        "tasks": [
          "Implementar Dashboard de Performance del Balanceador",
          "Añadir sistema de autenticación y autorización",
          "Implementar Audit Log para trazabilidad",
          "Mejorar manejo de errores con mensajes descriptivos"
        ]
      },
      {
        "priority": "P2 - Medium",
        "tasks": [
          "Implementar Dashboard de Callbacks",
          "Añadir notificaciones en tiempo real (WebSockets)",
          "Implementar exportación de datos (CSV/Excel)",
          "Optimizar consultas con caché"
        ]
      },
      {
        "priority": "P3 - Low",
        "tasks": [
          "Implementar búsqueda avanzada y filtros guardados",
          "Añadir temas personalizables",
          "Implementar modo offline con sincronización posterior"
        ]
      }
    ],
    
    "maintenanceGuidelines": [
      "Revisar y actualizar este documento cada vez que se añadan nuevas features",
      "Mantener sincronizados los casos Gherkin con la implementación real",
      "Actualizar el glosario cuando se introduzcan nuevos términos",
      "Revisar y actualizar las reglas de negocio cuando cambien requisitos",
      "Documentar nuevos common pitfalls cuando se descubran bugs recurrentes"
    ]
  }
}