{
  "metadata": {
    "proyecto": "SAM - Sistema Automático de Robots",
    "servicio": "sam.web",
    "fecha_analisis": "2025-10-27",
    "version_analisis": "1.0",
    "alcance": "Análisis de arquitectura, código y buenas prácticas del servicio web"
  },
  "resumen_ejecutivo": {
    "estado_general": "BUENO",
    "arquitectura": "Bien estructurada con separación clara Backend/Frontend",
    "cumplimiento_patrones": "Alto (90%)",
    "areas_criticas": 1,
    "areas_mejora": 9,
    "prioridad_accion": "MEDIA"
  },
  "fortalezas": [
    {
      "categoria": "Arquitectura",
      "descripcion": "Separación clara entre Backend (FastAPI) y Frontend (ReactPy)",
      "impacto": "ALTO",
      "archivos": [
        "src/sam/web/backend/api.py",
        "src/sam/web/frontend/app.py"
      ]
    },
    {
      "categoria": "Inyección de Dependencias",
      "descripcion": "Correcta implementación del patrón con DBDependencyProvider",
      "impacto": "ALTO",
      "archivos": [
        "src/sam/web/backend/dependencies.py",
        "src/sam/web/main.py"
      ]
    },
    {
      "categoria": "Código Reutilizable",
      "descripcion": "Sincronización centralizada usando SincronizadorComun (RFR-29)",
      "impacto": "MEDIO",
      "archivos": [
        "src/sam/web/backend/database.py"
      ]
    },
    {
      "categoria": "Gestión de Estado",
      "descripcion": "Hooks personalizados bien estructurados para robots, equipos y pools",
      "impacto": "MEDIO",
      "archivos": [
        "src/sam/web/frontend/hooks/use_robots_hook.py",
        "src/sam/web/frontend/hooks/use_equipos_hook.py",
        "src/sam/web/frontend/hooks/use_pools_hook.py"
      ]
    },
    {
      "categoria": "Validación",
      "descripcion": "Schemas Pydantic correctamente implementados",
      "impacto": "MEDIO",
      "archivos": [
        "src/sam/web/backend/schemas.py"
      ]
    }
  ],
  "issues_criticos": [
    {
      "id": "CRIT-001",
      "categoria": "Gestión de Recursos",
      "titulo": "Falta cierre del pool de conexiones en shutdown de FastAPI",
      "descripcion": "El pool de conexiones a la base de datos no se cierra correctamente cuando el servidor se detiene, causando posibles resource leaks.",
      "ubicacion": {
        "archivo": "src/sam/web/main.py",
        "funcion": "create_app"
      },
      "solucion_propuesta": {
        "descripcion": "Agregar evento shutdown en FastAPI",
        "codigo": "@app.on_event(\"shutdown\")\nasync def shutdown_event():\n    db_dependency_provider.get_db_connector().cerrar_conexiones_pool()\n    logger.info(\"Pool de conexiones cerrado correctamente.\")"
      },
      "prioridad": "ALTA",
      "impacto": "Resource leak en producción, conexiones huérfanas en SQL Server"
    }
  ],
  "issues_mejora": [
    {
      "id": "MEJORA-001",
      "categoria": "Lógica de Negocio",
      "titulo": "Complejidad innecesaria en get_available_devices_for_robot",
      "descripcion": "La función usa múltiples subconsultas NOT EXISTS que pueden simplificarse con una vista SQL o CTE.",
      "ubicacion": {
        "archivo": "src/sam/web/backend/database.py",
        "funcion": "get_available_devices_for_robot",
        "lineas": "148-175"
      },
      "solucion_propuesta": {
        "descripcion": "Crear una vista SQL en la base de datos que encapsule la lógica de disponibilidad",
        "alternativa": "Usar un Stored Procedure que retorne equipos disponibles dado un RobotId"
      },
      "prioridad": "MEDIA",
      "impacto": "Mejor rendimiento y mantenibilidad"
    },
    {
      "id": "MEJORA-002",
      "categoria": "Manejo de Errores",
      "titulo": "Propagación inconsistente de errores desde Stored Procedures",
      "descripcion": "Algunos endpoints capturan errores del SP pero no los tipifican correctamente (ej: update_device_status).",
      "ubicacion": {
        "archivo": "src/sam/web/backend/api.py",
        "funcion": "update_equipo_status",
        "lineas": "75-85"
      },
      "solucion_propuesta": {
        "descripcion": "Crear excepciones personalizadas y mapear códigos de error SQL a HTTP status codes apropiados"
      },
      "prioridad": "MEDIA",
      "impacto": "Mejor experiencia de usuario y debugging"
    },
    {
      "id": "MEJORA-003",
      "categoria": "Código Muerto",
      "titulo": "Dos versiones del modal de asignaciones de pools",
      "descripcion": "Existen PoolAssignmentsModal y PoolAssignmentsModal_old en el mismo archivo.",
      "ubicacion": {
        "archivo": "src/sam/web/frontend/features/modals/pool_modals.py",
        "lineas": "78-145 y 148-200"
      },
      "solucion_propuesta": {
        "descripcion": "Eliminar PoolAssignmentsModal_old si ya no se usa, o documentar por qué se mantiene"
      },
      "prioridad": "BAJA",
      "impacto": "Limpieza de código, reducción de confusión"
    },
    {
      "id": "MEJORA-004",
      "categoria": "Configuración",
      "titulo": "Intervalos de polling diferentes sin documentación",
      "descripcion": "Robots usa 15s, Equipos usa 30s. No hay documentación del por qué.",
      "ubicacion": {
        "archivo": "src/sam/web/frontend/hooks/use_robots_hook.py",
        "constante": "POLLING_INTERVAL_SECONDS = 15"
      },
      "ubicacion2": {
        "archivo": "src/sam/web/frontend/hooks/use_equipos_hook.py",
        "constante": "POLLING_INTERVAL_SECONDS = 30"
      },
      "solucion_propuesta": {
        "descripcion": "Unificar en una constante compartida o documentar el criterio de negocio"
      },
      "prioridad": "BAJA",
      "impacto": "Consistencia y mantenibilidad"
    },
    {
      "id": "MEJORA-005",
      "categoria": "API Legacy",
      "titulo": "Tres métodos de sincronización activos",
      "descripcion": "Existen sync, sync_robots y sync_equipos. El método sync parece legacy.",
      "ubicacion": {
        "archivo": "src/sam/web/backend/database.py",
        "funciones": ["sync_with_a360", "sync_robots_only", "sync_equipos_only"]
      },
      "solucion_propuesta": {
        "descripcion": "Deprecar sync_with_a360 y usar solo los métodos específicos, o documentar casos de uso"
      },
      "prioridad": "BAJA",
      "impacto": "Claridad de API"
    },
    {
      "id": "MEJORA-006",
      "categoria": "Código Duplicado",
      "titulo": "Componente DeviceList duplicado entre modals",
      "descripcion": "DeviceList en robots_modals.py y ResourceListBox en pool_modals.py son muy similares.",
      "ubicacion": {
        "archivo": "src/sam/web/frontend/features/modals/robots_modals.py",
        "componente": "DeviceList"
      },
      "ubicacion2": {
        "archivo": "src/sam/web/frontend/features/modals/pool_modals.py",
        "componente": "ResourceListBox"
      },
      "solucion_propuesta": {
        "descripcion": "Extraer a un componente compartido en src/sam/web/frontend/shared/"
      },
      "prioridad": "BAJA",
      "impacto": "DRY principle, mantenibilidad"
    },
    {
      "id": "MEJORA-007",
      "categoria": "Observabilidad",
      "titulo": "Logs insuficientes en operaciones críticas del frontend",
      "descripcion": "Los hooks realizan llamadas API pero no loguean errores o estados intermedios.",
      "ubicacion": {
        "archivos": [
          "src/sam/web/frontend/hooks/use_robots_hook.py",
          "src/sam/web/frontend/hooks/use_equipos_hook.py"
        ]
      },
      "solucion_propuesta": {
        "descripcion": "Agregar console.log o usar un logger centralizado para debugging en desarrollo"
      },
      "prioridad": "BAJA",
      "impacto": "Mejor debugging y soporte"
    },
    {
      "id": "MEJORA-008",
      "categoria": "Testing",
      "titulo": "Ausencia de tests automatizados",
      "descripcion": "No se observan tests unitarios ni de integración para endpoints o componentes.",
      "ubicacion": {
        "directorio_esperado": "tests/web/"
      },
      "solucion_propuesta": {
        "descripcion": "Crear tests con pytest para endpoints críticos y pytest-asyncio para hooks"
      },
      "prioridad": "MEDIA",
      "impacto": "Calidad y confianza en refactorizaciones"
    },
    {
      "id": "MEJORA-009",
      "categoria": "Documentación",
      "titulo": "Docstrings incompletos en componentes ReactPy",
      "descripcion": "Algunos componentes carecen de documentación sobre props esperados.",
      "ubicacion": {
        "ejemplos": [
          "src/sam/web/frontend/features/equipos/equipos_components.py",
          "src/sam/web/frontend/features/robots/robots_components.py"
        ]
      },
      "solucion_propuesta": {
        "descripcion": "Agregar docstrings con formato consistente describiendo parámetros y retornos"
      },
      "prioridad": "BAJA",
      "impacto": "Mantenibilidad y onboarding de nuevos desarrolladores"
    }
  ],
  "metricas_codigo": {
    "lineas_totales_estimadas": 3500,
    "archivos_analizados": 28,
    "componentes_reactpy": 25,
    "endpoints_api": 24,
    "hooks_personalizados": 4,
    "deuda_tecnica": "BAJA",
    "cobertura_tests": "0%"
  },
  "recomendaciones_priorizadas": [
    {
      "orden": 1,
      "accion": "Implementar cierre de pool de conexiones (CRIT-001)",
      "esfuerzo": "1 hora",
      "impacto": "ALTO"
    },
    {
      "orden": 2,
      "accion": "Crear tests para endpoints críticos (MEJORA-008)",
      "esfuerzo": "1-2 días",
      "impacto": "ALTO"
    },
    {
      "orden": 3,
      "accion": "Simplificar lógica de equipos disponibles (MEJORA-001)",
      "esfuerzo": "4 horas",
      "impacto": "MEDIO"
    },
    {
      "orden": 4,
      "accion": "Limpiar código muerto y duplicado (MEJORA-003, MEJORA-006)",
      "esfuerzo": "2 horas",
      "impacto": "BAJO"
    },
    {
      "orden": 5,
      "accion": "Mejorar documentación y logs (MEJORA-007, MEJORA-009)",
      "esfuerzo": "4 horas",
      "impacto": "BAJO"
    }
  ],
  "cumplimiento_arquitectura": {
    "patron_inyeccion_dependencias": true,
    "separacion_responsabilidades": true,
    "fail_fast_validation": true,
    "centralizacion_configuracion": true,
    "manejo_recursos": false,
    "logging_efectivo": "PARCIAL",
    "observaciones": "El servicio cumple con la mayoría de patrones definidos en la Guía de Arquitectura. La única violación crítica es el manejo de recursos (falta shutdown handler)."
  },
  "proximos_pasos": {
    "inmediato": "Implementar CRIT-001 antes del próximo despliegue a producción",
    "corto_plazo": "Abordar MEJORA-001, MEJORA-002 y MEJORA-008 en el próximo sprint",
    "largo_plazo": "Establecer proceso de code review para evitar acumulación de código muerto y duplicado"
  }
}
