{
  "meta": {
    "projectName": "SAM.Web - Servicio Web (ReactPy Frontend)",
    "documentVersion": "1.0",
    "description": "Estándar de código y arquitectura para el servicio web de SAM. Define convenciones de ReactPy, estructura de componentes, y patrones de desarrollo. Diseñado para ser interpretado por asistentes de IA.",
    "promptForAI": "Al crear o refactorizar componentes ReactPy en SAM.Web, sigue estrictamente estas directivas. Mantén consistencia con la guía de desarrollo general de SAM (FastAPI backend, inyección de dependencias, etc.).",
    "techStack": {
      "frontend": "ReactPy v1.1.0",
      "backend": "FastAPI v0.115.12",
      "css": "PicoCSS + Custom CSS",
      "database": "SQL Server (pyodbc v5.2.0)",
      "testing": "pytest v8.4.1 (sin tests actualmente)"
    }
  },
  "architecturalPrinciples": [
    {
      "principleTitle": "Estructura de Directorios y Nomenclatura",
      "principleDescription": "Organización clara de componentes ReactPy siguiendo PEP8 y convenciones React adaptadas a Python.",
      "guidelines": [
        {
          "guidelineTitle": "Convención de Nombres",
          "details": [
            {
              "concept": "Archivos y Módulos",
              "explanation": "Usar snake_case para archivos: robot_list.py, status_badge.py. Ejemplo: './frontend/features/components/robots_components.py' → './frontend/features/components/robot_list.py'",
              "rationale": "PEP 8 para Python, manteniendo claridad"
            },
            {
              "concept": "Componentes ReactPy",
              "explanation": "Usar PascalCase para componentes: @component def RobotList():, @component def StatusBadge():",
              "rationale": "Convención React adaptada a Python"
            },
            {
              "concept": "Funciones y Variables",
              "explanation": "Usar snake_case: def fetch_robots(), robot_name, is_loading",
              "rationale": "PEP 8 estándar de Python"
            },
            {
              "concept": "Hooks Personalizados",
              "explanation": "Usar prefix 'use_' en snake_case: def use_robots(), def use_debounced_value()",
              "rationale": "Convención React adaptada a Python"
            },
            {
              "concept": "Constantes y Config",
              "explanation": "Usar UPPER_SNAKE_CASE: API_TIMEOUT = 30, MAX_RETRIES = 3",
              "rationale": "PEP 8 para constantes"
            }
          ]
        },
        {
          "guidelineTitle": "Estructura de Componentes",
          "details": [
            {
              "concept": "Separación de Responsabilidades",
              "explanation": "Cada componente debe tener una responsabilidad única. Separar lógica de presentación usando hooks personalizados.",
              "exampleCode": {
                "language": "python",
                "filename": "frontend/features/components/robot_list.py",
                "correct": "# ✅ BIEN - Componente enfocado en presentación\n@component\ndef RobotList(robots, on_robot_select):\n    return html.div(\n        html.h3(\"Lista de Robots\"),\n        html.table([\n            html.thead(html.tr([html.th(\"Nombre\"), html.th(\"Estado\")])),\n            html.tbody([\n                html.tr(\n                    {\"key\": robot[\"id\"], \"on_click\": lambda: on_robot_select(robot)},\n                    [html.td(robot[\"name\"]), html.td(StatusBadge(robot[\"status\"]))]\n                ) for robot in robots\n            ])\n        ])\n    )",
                "incorrect": "# ❌ MAL - Lógica mezclada con UI\n@component  \ndef RobotList():\n    robots, set_robots = use_state([])\n    loading, set_loading = use_state(True)\n    \n    @use_effect\n    async def fetch_data():\n        # 50 líneas de lógica de fetching aquí...\n        pass\n    \n    return html.div(...)"
              }
            },
            {
              "concept": "Props Explícitas",
              "explanation": "Siempre declarar props explicitamente con type hints. Evitar **kwargs en componentes.",
              "exampleCode": {
                "language": "python",
                "correct": "from typing import List, Callable\n\n@component\ndef RobotList(robots: List[dict], on_robot_select: Callable, loading: bool = False):\n    pass",
                "incorrect": "@component\ndef RobotList(**props):\n    robots = props.get(\"robots\", [])"
              }
            }
          ]
        }
      ]
    },
    {
      "principleTitle": "Hooks y Lógica de Estado",
      "principleDescription": "Centralizar lógica en hooks reutilizables, siguiendo el patrón de React adaptado a Python.",
      "guidelines": [
        {
          "guidelineTitle": "Hooks Personalizados",
          "details": [
            {
              "concept": "Separación de Lógica",
              "explanation": "Los hooks deben encapsular lógica reutilizable: fetching de datos, manejo de formularios, estado local.",
              "exampleCode": {
                "language": "python",
                "filename": "frontend/hooks/use_robots_hook.py",
                "code": "from typing import Dict, List, Any\nfrom reactpy import use_state, use_effect\nfrom frontend.api.api_client import api_client\n\ndef use_robots(pool_filter: str = \"all\") -> Dict[str, Any]:\n    \"\"\"Hook para manejar estado de robots con fetching automático.\"\"\"\n    robots, set_robots = use_state([])\n    loading, set_loading = use_state(True)\n    error, set_error = use_state(None)\n    \n    @use_effect(dependencies=[pool_filter])\n    async def fetch_robots():\n        try:\n            set_loading(True)\n            params = {\"pool\": pool_filter} if pool_filter != \"all\" else None\n            data = await api_client.get(\"/robots\", params=params)\n            set_robots(data)\n        except Exception as e:\n            set_error(str(e))\n        finally:\n            set_loading(False)\n    \n    return {\n        \"robots\": robots,\n        \"loading\": loading,\n        \"error\": error,\n        \"refetch\": fetch_robots\n    }"
              }
            }
          ]
        },
        {
          "guidelineTitle": "Manejo de Estado Global",
          "details": [
            {
              "concept": "Context Pattern",
              "explanation": "Usar create_context para estado compartido entre componentes (usuario actual, configuración, notificaciones).",
              "exampleCode": {
                "language": "python",
                "filename": "frontend/state/app_context.py",
                "code": "from reactpy import create_context, use_context\nfrom typing import Dict, Any, Callable\n\nAppContext = create_context({})\n\ndef AppProvider(children, value: Dict[str, Any]):\n    return AppContext(value, children)\n\ndef use_app_context() -> Dict[str, Any]:\n    \"\"\"Hook para acceder al contexto global de la app.\"\"\"\n    return use_context(AppContext)\n\n# Uso en app.py\n@component\ndef App():\n    context_value = {\n        \"user\": {\"name\": \"Admin\", \"role\": \"operator\"},\n        \"notifications\": [],\n        \"api_client\": api_client,\n        \"add_notification\": lambda msg: print(f\"Notificación: {msg}\")\n    }\n    \n    return AppProvider(\n        value=context_value,\n        children=Router(...)\n    )"
              }
            }
          ]
        }
      ]
    },
    {
      "principleTitle": "Componentes Comunes y Reutilización",
      "principleDescription": "Crear biblioteca de componentes base para consistencia visual y reducir duplicación.",
      "guidelines": [
        {
          "guidelineTitle": "Componentes Base",
          "details": [
            {
              "concept": "DataTable Genérica",
              "explanation": "Crear componente de tabla reutilizable para todas las listas de datos.",
              "exampleCode": {
                "language": "python",
                "filename": "frontend/shared/data_table.py",
                "code": "from typing import List, Dict, Any, Optional, Callable\nfrom reactpy import component, html\n\n@component\ndef DataTable(\n    data: List[Dict[str, Any]],\n    columns: List[Dict[str, Any]],\n    loading: bool = False,\n    on_row_click: Optional[Callable] = None,\n    actions: Optional[List[Dict[str, Any]]] = None,\n    empty_message: str = \"No hay datos disponibles\"\n) -> html.div:\n    \"\"\"Tabla genérica reutilizable para listados de datos.\"\"\"\n    \n    if loading:\n        return LoadingSpinner()\n    \n    if not data:\n        return EmptyState(message=empty_message)\n    \n    return html.table(\n        {\"class_name\": \"data-table\"},\n        html.thead(\n            html.tr([\n                html.th(col[\"label\"]) for col in columns\n            ] + ([html.th(\"Acciones\")] if actions else []))\n        ),\n        html.tbody([\n            html.tr(\n                {\n                    \"key\": str(row.get(\"id\", idx)),\n                    \"on_click\": lambda: on_row_click(row) if on_row_click else None,\n                    \"class_name\": \"clickable\" if on_row_click else \"\"\n                },\n                [\n                    html.td(\n                        col[\"render\"](row) if col.get(\"render\") \n                        else str(row.get(col[\"key\"], \"\"))\n                    )\n                    for col in columns\n                ]\n            )\n            for idx, row in enumerate(data)\n        ])\n    )"
              }
            },
            {
              "concept": "Estados de Carga/Error/Vacío",
              "explanation": "Componentes consistentes para manejar estados asíncronos.",
              "exampleCode": {
                "language": "python",
                "filename": "frontend/shared/async_content.py",
                "code": "@component\ndef AsyncContent(\n    loading: bool,\n    error: Optional[str] = None,\n    data: Optional[List] = None,\n    loading_component=None,\n    error_component=None,\n    empty_component=None,\n    children=None\n):\n    \"\"\"Wrapper para manejar estados de carga de manera consistente.\"\"\"\n    \n    if loading:\n        return loading_component or LoadingSpinner()\n    \n    if error:\n        return error_component or ErrorAlert(message=error)\n    \n    if data is not None and len(data) == 0:\n        return empty_component or EmptyState()\n    \n    return children\n\n# Componentes auxiliares\n@component\ndef LoadingSpinner():\n    return html.div(\n        {\"class_name\": \"loading-spinner\"},\n        \"Cargando...\"\n    )\n\n@component\ndef ErrorAlert(message: str):\n    return html.div(\n        {\"class_name\": \"error-alert\"},\n        f\"Error: {message}\"\n    )\n\n@component\ndef EmptyState(message: str = \"No hay datos disponibles\"):\n    return html.div(\n        {\"class_name\": \"empty-state\"},\n        message\n    )"
              }
            }
          ]
        }
      ]
    },
    {
      "principleTitle": "Estilos y CSS",
      "principleDescription": "Uso consistente de PicoCSS + Custom CSS manteniendo simplicidad y legibilidad.",
      "guidelines": [
        {
          "guidelineTitle": "Organización de Estilos",
          "details": [
            {
              "concept": "CSS Centralizado",
              "explanation": "Definir clases CSS reutilizables en archivos centrales, evitar estilos inline.",
              "exampleCode": {
                "language": "python",
                "filename": "frontend/shared/styles.py",
                "code": "\"\"\"Clases CSS reutilizables para mantener consistencia visual.\"\"\"\n\n# Botones\nBUTTON_PRIMARY = \"btn btn-primary\"\nBUTTON_DANGER = \"btn btn-danger\"\nBUTTON_SECONDARY = \"btn btn-secondary\"\n\n# Estados\nSTATUS_RUNNING = \"badge bg-success\"\nSTATUS_STOPPED = \"badge bg-error\"\nSTATUS_UNKNOWN = \"badge bg-warning\"\nSTATUS_COOLING = \"badge bg-info\"\n\n# Layout\nCARD = \"card\"\nGRID = \"grid\"\nCONTAINER = \"container\"\n\n# Uso en componentes:\nfrom frontend.shared.styles import BUTTON_PRIMARY, STATUS_RUNNING\n\n@component\ndef StatusBadge(status: str):\n    status_classes = {\n        \"running\": STATUS_RUNNING,\n        \"stopped\": STATUS_STOPPED,\n        \"unknown\": STATUS_UNKNOWN,\n        \"cooling\": STATUS_COOLING,\n    }\n    \n    return html.span(\n        {\"class_name\": status_classes.get(status, STATUS_UNKNOWN)},\n        status.title()\n    )"
              }
            },
            {
              "concept": "PicoCSS Integration",
              "explanation": "Aprovechar clases de PicoCSS cuando sea posible, extender solo cuando necesario.",
              "exampleCode": {
                "language": "python",
                "correct": "# ✅ Usar clases de PicoCSS\nhtml.button(\n    {\"class_name\": \"btn btn-primary\"},\n    \"Guardar\"\n)\n\n# ✅ Extender con custom CSS cuando necesario\nhtml.div(\n    {\"class_name\": \"card custom-robot-card\"},\n    content\n)",
                "incorrect": "# ❌ Estilos inline\nhtml.button(\n    {\n        \"style\": {\"backgroundColor\": \"blue\", \"padding\": \"10px\"}\n    },\n    \"Guardar\"\n)"
              }
            }
          ]
        }
      ]
    },
    {
      "principleTitle": "Integración con Backend (FastAPI)",
      "principleDescription": "Patrones consistentes para comunicación con el backend siguiendo principios de SAM.",
      "guidelines": [
        {
          "guidelineTitle": "Cliente API",
          "details": [
            {
              "concept": "Cliente Centralizado",
              "explanation": "Usar un único cliente HTTP con manejo centralizado de errores y autenticación.",
              "exampleCode": {
                "language": "python",
                "filename": "frontend/api/api_client.py",
                "code": "import httpx\nfrom typing import Any, Dict, Optional\nfrom frontend.utils.exceptions import APIError\n\nclass APIClient:\n    \"\"\"Cliente HTTP centralizado para comunicación con FastAPI backend.\"\"\"\n    \n    def __init__(self, base_url: str, api_key: str):\n        self.base_url = base_url.rstrip(\"/\")\n        self.api_key = api_key\n        self.client = httpx.AsyncClient(\n            base_url=self.base_url,\n            headers={\"Authorization\": f\"Bearer {api_key}\"},\n            timeout=30.0\n        )\n    \n    async def get(self, endpoint: str, params: Optional[Dict] = None) -> Any:\n        \"\"\"GET request con manejo de errores centralizado.\"\"\"\n        try:\n            response = await self.client.get(endpoint, params=params)\n            response.raise_for_status()\n            return response.json()\n        except httpx.HTTPStatusError as e:\n            raise APIError(f\"API Error {e.response.status_code}: {e.response.text}\")\n        except httpx.RequestError as e:\n            raise APIError(f\"Request Error: {str(e)}\")\n    \n    async def post(self, endpoint: str, data: Dict) -> Any:\n        \"\"\"POST request con manejo de errores.\"\"\"\n        try:\n            response = await self.client.post(endpoint, json=data)\n            response.raise_for_status()\n            return response.json()\n        except httpx.HTTPStatusError as e:\n            raise APIError(f\"API Error {e.response.status_code}: {e.response.text}\")\n    \n    async def close(self):\n        \"\"\"Cerrar conexiones HTTP.\"\"\"\n        await self.client.aclose()\n\n# Cliente global (inyectado por contexto)\napi_client = APIClient(\n    base_url=\"http://localhost:8000/api\",\n    api_key=\"sam-api-key\"\n)"
              }
            }
          ]
        },
        {
          "guidelineTitle": "Manejo de Errores",
          "details": [
            {
              "concept": "Errores de Usuario Amigables",
              "explanation": "Convertir errores técnicos en mensajes comprensibles para el usuario.",
              "exampleCode": {
                "language": "python",
                "filename": "frontend/utils/exceptions.py",
                "code": "class APIError(Exception):\n    \"\"\"Error de comunicación con la API.\"\"\"\n    \n    def __init__(self, message: str, user_message: str = None):\n        self.message = message\n        self.user_message = user_message or \"Ocurrió un error al procesar la solicitud.\"\n        super().__init__(self.message)\n\nclass ValidationError(APIError):\n    \"\"\"Error de validación de datos.\"\"\"\n    pass\n\nclass NotFoundError(APIError):\n    \"\"\"Recurso no encontrado.\"\"\"\n    def __init__(self, message: str):\n        super().__init__(message, \"El recurso solicitado no fue encontrado.\")\n\n# Uso en hooks:\ndef handle_api_error(error: Exception) -> str:\n    \"\"\"Convertir error técnico a mensaje de usuario.\"\"\"\n    if isinstance(error, ValidationError):\n        return f\"Datos inválidos: {error.user_message}\"\n    elif isinstance(error, NotFoundError):\n        return error.user_message\n    elif isinstance(error, APIError):\n        return error.user_message\n    else:\n        return \"Error inesperado. Por favor, intente nuevamente.\""
              }
            }
          ]
        }
      ]
    },
    {
      "principleTitle": "Performance y Optimización",
      "principleDescription": "Mejores prácticas para ReactPy específicas de performance.",
      "guidelines": [
        {
          "guidelineTitle": "Renderizado Eficiente",
          "details": [
            {
              "concept": "Keys en Listas",
              "explanation": "Siempre usar key únicas en componentes de lista para optimizar re-renderizados.",
              "exampleCode": {
                "language": "python",
                "correct": "# ✅ Con key única\nhtml.ul([\n    html.li({\"key\": robot[\"id\"]}, robot[\"name\"])\n    for robot in robots\n])",
                "incorrect": "# ❌ Sin key\nhtml.ul([\n    html.li(robot[\"name\"]) \n    for robot in robots\n])"
              }
            },
            {
              "concept": "Memoización con use_memo",
              "explanation": "Usar use_memo para cálculos costosos que no cambian frecuentemente.",
              "exampleCode": {
                "language": "python",
                "code": "from reactpy import use_memo\n\n@component\ndef RobotStats(robots: List[dict]):\n    # Calcular estadísticas solo cuando robots cambie\n    stats = use_memo(\n        lambda: {\n            \"total\": len(robots),\n            \"running\": len([r for r in robots if r[\"status\"] == \"running\"]),\n            \"stopped\": len([r for r in robots if r[\"status\"] == \"stopped\"])\n        },\n        dependencies=[robots]\n    )\n    \n    return html.div(\n        f\"Total: {stats['total']}, Running: {stats['running']}, Stopped: {stats['stopped']}\"\n    )"
              }
            }
          ]
        }
      ]
    },
    {
      "principleTitle": "Testing y Calidad",
      "principleDescription": "Preparar el código para testing y mantener alta calidad.",
      "guidelines": [
        {
          "guidelineTitle": "Preparación para Testing",
          "details": [
            {
              "concept": "Inyección de Dependencias",
              "explanation": "Escribir componentes con dependencias inyectables para facilitar mocking.",
              "exampleCode": {
                "language": "python",
                "correct": "@component\ndef RobotList(api_client: APIClient = None):\n    \"\"\"Permite inyectar api_client para testing.\"\"\"\n    client = api_client or use_app_context()[\"api_client\"]\n    # ... uso del cliente",
                "incorrect": "@component\ndef RobotList():\n    # Cliente hardcodeado, difícil de testear\n    client = APIClient(base_url=\"http://localhost:8000\")\n    # ... uso del cliente"
              }
            },
            {
              "concept": "Funciones Puras cuando sea posible",
              "explanation": "Extraer lógica pura en funciones separadas para facilitar testing unitario.",
              "exampleCode": {
                "language": "python",
                "code": "# Función pura, fácil de testear\ndef filter_robots_by_pool(robots: List[dict], pool: str) -> List[dict]:\n    \"\"\"Filtrar robots por pool. Función pura para testing fácil.\"\"\"\n    if pool == \"all\":\n        return robots\n    return [robot for robot in robots if robot.get(\"pool\") == pool]\n\n# Uso en componente\n@component\ndef RobotList(robots: List[dict], pool_filter: str):\n    filtered_robots = filter_robots_by_pool(robots, pool_filter)\n    return html.div(...)"
              }
            }
          ]
        }
      ]
    }
  ],
  "migrationChecklist": {
    "phase1": {
      "title": "Renombrado y Estructura (1 día)",
      "tasks": [
        "Renombrar archivos a snake_case: robots_components.py → robot_list.py",
        "Crear directorio frontend/shared/ para componentes comunes",
        "Mover componentes base a frontend/shared/",
        "Actualizar imports en __init__.py"
      ]
    },
    "phase2": {
      "title": "Componentes Base (2 días)",
      "tasks": [
        "Crear DataTable genérica en frontend/shared/data_table.py",
        "Crear AsyncContent en frontend/shared/async_content.py",
        "Crear estilos centralizados en frontend/shared/styles.py",
        "Refactor RobotList para usar DataTable"
      ]
    },
    "phase3": {
      "title": "Hooks y Estado (2 días)",
      "tasks": [
        "Crear use_robots_hook.py con type hints completos",
        "Crear AppContext para estado global",
        "Refactor componentes para usar hooks",
        "Mover lógica de fetching a hooks"
      ]
    },
    "phase4": {
      "title": "Testing Setup (1 día)",
      "tasks": [
        "Configurar pytest para ReactPy",
        "Crear tests para funciones puras",
        "Crear tests para componentes críticos",
        "Documentar cómo escribir tests"
      ]
    }
  },
  "fileTemplates": {
    "component": "# frontend/features/components/component_name.py\n\"\"\"Componente para [descripción].\"\"\"\n\nfrom typing import [types_needed]\nfrom reactpy import component, html\nfrom frontend.shared.styles import [style_constants]\n\n@component\ndef ComponentName(prop1: type, prop2: type = default) -> html.div:\n    \"\"\"[Descripción del componente].\"\"\"\n    \n    return html.div(\n        {\"class_name\": \"card\"},\n        html.h3(\"Título\"),\n        # Contenido aquí\n    )",
    "hook": "# frontend/hooks/use_hook_name.py\n\"\"\"Hook personalizado para [descripción].\"\"\"\n\nfrom typing import [types_needed]\nfrom reactpy import use_state, use_effect\nfrom frontend.api.api_client import api_client\n\ndef use_hook_name(param: type) -> Dict[str, Any]:\n    \"\"\"[Descripción del hook].\"\"\"\n    \n    state, set_state = use_state(initial_value)\n    \n    @use_effect(dependencies=[param])\n    async def fetch_data():\n        # Lógica aquí\n        pass\n    \n    return {\n        \"data\": data,\n        \"loading\": loading,\n        \"error\": error\n    }"
  }
}